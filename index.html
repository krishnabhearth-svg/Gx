// ========================================
// SEMANTIC DATABASE MANAGEMENT WITH ERROR HANDLING
// ========================================
let semanticDatabase = null;
let keywordsIndex = null;
let databaseStatus = 'loading';

async function loadSemanticDatabase() {
    try {
        console.log('Attempting to load semantic database...');
        
        // Try to load main semantic database
        const dbResponse = await fetch('deepseek_json_20251016_d2343b.json');
        
        if (!dbResponse.ok) {
            throw new Error(`HTTP error! status: ${dbResponse.status}`);
        }
        
        const dbData = await dbResponse.json();
        
        // Validate the JSON structure
        if (!dbData.gx_semantic_database || !dbData.gx_semantic_database.semantic_vectors) {
            throw new Error('Invalid JSON structure: missing gx_semantic_database.semantic_vectors');
        }
        
        semanticDatabase = dbData.gx_semantic_database.semantic_vectors;
        console.log('Main semantic database loaded successfully');
        
        // Try to load keywords index (optional - can work without it)
        try {
            const indexResponse = await fetch('keywords-index.json');
            if (indexResponse.ok) {
                keywordsIndex = await indexResponse.json();
                console.log('Keywords index loaded successfully');
            } else {
                console.warn('Keywords index not found, continuing without it');
                keywordsIndex = null;
            }
        } catch (indexError) {
            console.warn('Could not load keywords index:', indexError);
            keywordsIndex = null;
        }
        
        databaseStatus = 'loaded';
        return true;
        
    } catch (error) {
        console.error('Error loading semantic database:', error);
        databaseStatus = 'failed';
        
        // Show user-friendly error
        showDatabaseError(error.message);
        return false;
    }
}

function showDatabaseError(errorMessage) {
    // Create a subtle error indicator in the UI
    const header = document.querySelector('header');
    const errorDiv = document.createElement('div');
    errorDiv.className = 'bg-yellow-50 border-l-4 border-yellow-400 p-4';
    errorDiv.innerHTML = `
        <div class="flex">
            <div class="flex-shrink-0">
                <i class="fas fa-exclamation-triangle text-yellow-400"></i>
            </div>
            <div class="ml-3">
                <p class="text-sm text-yellow-700">
                    Semantic database loading issue: ${errorMessage}. 
                    Using fallback mode - basic functionality available.
                    <button onclick="this.parentElement.parentElement.parentElement.remove()" class="ml-2 underline">Dismiss</button>
                </p>
            </div>
        </div>
    `;
    header.parentNode.insertBefore(errorDiv, header.nextSibling);
}

// Enhanced semantic matching with fallback
function findSemanticMatches(userInput) {
    if (databaseStatus !== 'loaded' || !semanticDatabase) {
        console.log('Using fallback semantic matching - database not available');
        return generateFallbackMatches(userInput);
    }
    
    const keywords = userInput.toLowerCase().split(/\s+/).filter(word => word.length > 2);
    const matches = [];
    const matchedDomains = new Set();
    
    keywords.forEach(keyword => {
        // Direct match
        if (semanticDatabase[keyword]) {
            matches.push({
                keyword: keyword,
                data: semanticDatabase[keyword],
                score: 1.0,
                source: 'direct'
            });
            matchedDomains.add(semanticDatabase[keyword].domain);
        }
        // Fuzzy match from index if available
        else if (keywordsIndex && keywordsIndex[keyword]) {
            keywordsIndex[keyword].forEach(matchedKeyword => {
                if (semanticDatabase[matchedKeyword] && !matches.find(m => m.keyword === matchedKeyword)) {
                    matches.push({
                        keyword: matchedKeyword,
                        data: semanticDatabase[matchedKeyword],
                        score: 0.8,
                        source: 'fuzzy'
                    });
                    matchedDomains.add(semanticDatabase[matchedKeyword].domain);
                }
            });
        }
    });
    
    console.log(`Found ${matches.length} semantic matches for: "${userInput}"`);
    
    return {
        matches: matches,
        domains: Array.from(matchedDomains),
        primaryDomain: matches.length > 0 ? matches[0].data.domain : 'GENERAL',
        databaseUsed: true
    };
}

// Fallback matching when database is not available
function generateFallbackMatches(userInput) {
    const lowerInput = userInput.toLowerCase();
    const matches = [];
    let primaryDomain = 'GENERAL';
    
    // Simple keyword-based domain detection
    const domainPatterns = {
        'LEARNING': ['learn', 'study', 'tutorial', 'course', 'education', 'how to'],
        'WELLNESS': ['health', 'mental', 'wellness', 'meditation', 'therapy', 'healing'],
        'TECH': ['build', 'create', 'develop', 'code', 'programming', 'web', 'app'],
        'RESEARCH': ['research', 'scholar', 'academic', 'paper', 'study', 'citation']
    };
    
    for (const [domain, patterns] of Object.entries(domainPatterns)) {
        if (patterns.some(pattern => lowerInput.includes(pattern))) {
            primaryDomain = domain;
            break;
        }
    }
    
    // Create basic match objects
    const keywords = userInput.split(/\s+/).filter(word => word.length > 2);
    keywords.forEach(keyword => {
        matches.push({
            keyword: keyword,
            data: {
                domain: primaryDomain,
                vector: [0.1, 0.1, 0.1], // dummy vector
                filters: [],
                layer1_title: `Refine your ${primaryDomain.toLowerCase()} search`,
                layer1_description: "Let's narrow down what you're looking for",
                layer1_options: getFallbackOptions(primaryDomain, 1),
                layer2_title: "Choose your approach",
                layer2_description: "How would you like to proceed?",
                layer2_options: getFallbackOptions(primaryDomain, 2),
                layer3_title: "Final preferences",
                layer3_description: "Any specific requirements?",
                layer3_options: getFallbackOptions(primaryDomain, 3)
            },
            score: 0.5,
            source: 'fallback'
        });
    });
    
    return {
        matches: matches,
        domains: [primaryDomain],
        primaryDomain: primaryDomain,
        databaseUsed: false
    };
}

function getFallbackOptions(domain, layer) {
    const options = {
        'LEARNING': {
            1: [
                { text: "Beginner Level", value: "beginner tutorial", icon: "🌱" },
                { text: "Intermediate", value: "intermediate guide", icon: "📚" },
                { text: "Advanced", value: "advanced techniques", icon: "🎓" }
            ],
            2: [
                { text: "Video Tutorials", value: "video tutorial", icon: "🎥" },
                { text: "Written Guides", value: "documentation guide", icon: "📖" },
                { text: "Interactive", value: "interactive course", icon: "💻" }
            ],
            3: [
                { text: "Quick Start", value: "quick start", icon: "⚡" },
                { text: "Comprehensive", value: "comprehensive course", icon: "📅" },
                { text: "Self-Paced", value: "self-paced learning", icon: "🔄" }
            ]
        },
        'WELLNESS': {
            1: [
                { text: "Mental Health", value: "mental health", icon: "🧠" },
                { text: "Physical Wellness", value: "fitness wellness", icon: "💪" },
                { text: "Nutrition", value: "nutrition diet", icon: "🥗" }
            ],
            2: [
                { text: "Professional Help", value: "therapist counselor", icon: "👨‍⚕️" },
                { text: "Self-Help", value: "self-help resources", icon: "📚" },
                { text: "Community", value: "support community", icon: "👥" }
            ],
            3: [
                { text: "Online Resources", value: "online virtual", icon: "💻" },
                { text: "Local Services", value: "near me local", icon: "📍" },
                { text: "Both Options", value: "online or in-person", icon: "🔄" }
            ]
        },
        'TECH': {
            1: [
                { text: "Web Development", value: "web development", icon: "🌐" },
                { text: "Mobile Apps", value: "mobile app development", icon: "📱" },
                { text: "Data Science", value: "data science", icon: "📊" }
            ],
            2: [
                { text: "Tutorials", value: "tutorial guide", icon: "📖" },
                { text: "Tools", value: "tools resources", icon: "🧰" },
                { text: "Best Practices", value: "best practices", icon: "⭐" }
            ],
            3: [
                { text: "Free Resources", value: "free open source", icon: "💚" },
                { text: "Paid Courses", value: "premium course", icon: "💼" },
                { text: "Both", value: "", icon: "🔄" }
            ]
        },
        'RESEARCH': {
            1: [
                { text: "Literature Review", value: "literature review", icon: "📚" },
                { text: "Methodology", value: "research methodology", icon: "🔬" },
                { text: "Data Analysis", value: "data analysis", icon: "📊" }
            ],
            2: [
                { text: "Academic Papers", value: "academic papers", icon: "📄" },
                { text: "Case Studies", value: "case studies", icon: "📋" },
                { text: "Reviews", value: "review articles", icon: "👁️" }
            ],
            3: [
                { text: "Recent Studies", value: "2023 2024", icon: "📅" },
                { text: "Classic Works", value: "seminal works", icon: "📜" },
                { text: "All Timeframes", value: "", icon: "🕐" }
            ]
        }
    };
    
    return options[domain]?.[layer] || options['GENERAL'][layer];
}

// Enhanced layer generator with database status awareness
const LayerGenerator = {
    generateSemanticLayer(layerNum, semanticData, previousChoices, query) {
        // If database failed or no semantic data, use fallback
        if (databaseStatus === 'failed' || !semanticData || !semanticData.matches.length) {
            console.log(`Using fallback layer generation for layer ${layerNum}`);
            return this.generateFallbackLayer(layerNum, query);
        }
        
        // If we have semantic data but it's from fallback, indicate that
        if (semanticData && !semanticData.databaseUsed) {
            console.log(`Using enhanced fallback for layer ${layerNum}`);
        }
        
        const primaryMatch = semanticData.matches[0].data;
        
        if (layerNum === 1) {
            return {
                title: primaryMatch.layer1_title || "Refine your exploration",
                description: primaryMatch.layer1_description || "Help us understand your needs better",
                options: (primaryMatch.layer1_options || []).map(option => ({
                    text: option.text || option,
                    value: option.value || option,
                    icon: option.icon || "🔍"
                })),
                databaseUsed: semanticData.databaseUsed
            };
        }
        
        // ... rest of your layer generation code remains the same
        // Just make sure to include databaseUsed in the return object
    }
};

// Enhanced initialization with status monitoring
async function init() {
    console.log('Initializing Gx Search...');
    
    // Show loading state for database
    const initialSearch = document.getElementById('initial-search');
    const loadingHtml = `
        <div class="text-center py-4">
            <div class="spinner mb-4"></div>
            <p class="text-gray-600">Loading semantic database...</p>
        </div>
    `;
    initialSearch.insertAdjacentHTML('beforeend', loadingHtml);
    
    // Load semantic database
    const dbLoaded = await loadSemanticDatabase();
    
    // Remove loading indicator
    const loadingIndicator = initialSearch.querySelector('.spinner').parentElement;
    if (loadingIndicator) {
        loadingIndicator.remove();
    }
    
    // Add status indicator to UI
    const statusBadge = document.createElement('div');
    statusBadge.className = `text-xs px-2 py-1 rounded-full mt-2 ${
        databaseStatus === 'loaded' ? 'bg-green-100 text-green-800' : 
        databaseStatus === 'failed' ? 'bg-yellow-100 text-yellow-800' : 
        'bg-gray-100 text-gray-800'
    }`;
    statusBadge.textContent = `Database: ${databaseStatus}`;
    document.querySelector('header .flex.items-center.space-x-3').appendChild(statusBadge);
    
    // Set up event listeners
    setupEventListeners();
    
    console.log(`Gx initialization complete. Database status: ${databaseStatus}`);
}

// Add this to your existing setupEventListeners function
function setupEventListeners() {
    // Your existing event listener code...
    
    // Add debug info to console when searching
    document.getElementById('initial-search-btn').addEventListener('click', function() {
        const query = document.getElementById('initial-input').value.trim();
        if (query) {
            console.log(`Starting search for: "${query}"`);
            console.log(`Database status: ${databaseStatus}`);
            startGxJourney(query);
        }
    });
}
